<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sqlite-manager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sqlite-manager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Module to manage the sqlite database.
 * @module sqlite-manager
 * @author Alexandru Mereacre &lt;mereacre@gmail.com>
 */

module.exports = (function() {
  "use strict";

  const _ = require("lodash");
  const sqlite3 = require("sqlite3");
  const Promise = require("bluebird");
  const shortid = require("shortid");
  const builder = require("mongo-sql");
  // node.js built-in
  const util = require("util");
  const fs = require("fs");
  const path = require("path");

  const sqliteConstants = require("./sqlite-constants.js");
  const sqliteInfoTable = require("./sqlite-info-table.js");
  const sqliteConverter = require("./sqlite-schema-converter.js");
  const sqliteHelper = require("./sqlite-helper.js");

  const manager = {};
  const generalSchema = {};
  const queryLimit = sqliteConstants.SQLITE_QUERY_LIMIT;

  Promise.promisifyAll(sqlite3);

  /**
   * @global
   * @typedef  {object} DatasetData
   * @property  {object} metaData - The dataset metadata (see `nqmMeta` option in `getDatasetData`).
   * @property  {string} metaDataUrl - The URL to the dataset metadata (see `nqmMeta` option in `getDatasetData`).
   * @property  {object[]} data - The dataset documents.
   */

  /**
   * An object the shows the status of a command.
   * @global
   * @typedef  {object} CommandResult
   * @property  {string} commandId - The auto-generated unique id of the command.
   * @property  {object|string} response - The response of the command.
   *     If a command is sent asynchronously, this will
   *     simply be the string `"ack"`.
   *     In synchronous mode, this will usually be an object consisting of the
   *     primary key of the data that was affected by the command.
   * @property  {object} result - Contains detailed error information
   *     when available.
   * @property  {array} result.errors - Will contain error information
   *     when appropriate.
   * @property  {array} result.commit - Contains details of each
   *     committed document.
   */

  /**
   * Makes an empty {@link CommandResult}
   *
   * Async since shortid is probably really slow
   * @returns {Promise&lt;CommandResult>} An empty commandResult.
   */
  async function makeEmptyCommandResult() {
    return {
      // reduce change of commandId having multiple shortids appended together
      // [x^2/(2*64**7) = 0.5](https://www.wolframalpha.com/input/?i=x%5E2%2F(2*64**21)+%3D+0.5)
      // using just one shortid which might have only 4 characters where each
      // character has 64 possibilites means you only need 2 million commands
      // until you have a 50% change of a collision
      commandId: shortid.generate() + shortid.generate() + shortid.generate(),
      response: null,
      result: {
        errors: [],
        commit: [],
      },
    };
  }

   /**
    * An object that describes a Resource/Dataset
    * @global
    * @typedef  {object} Resource
    * @property  {string} description
    * @property  {string} id - The unique ID of the resource
    * @property  {string} name
    * @property  {string[]} parents
    * @property  {object} schemaDefinition
    * @property  {string[]} tags
    */

  const mkdir = util.promisify(fs.mkdir);
  const stat = util.promisify(fs.stat);

  /**
   * Makes a directory and all parent directories.
   * @param {PathLike} dirPath The path to the dir to make.
   * @param {integer} [its=100] The maximum number of recursions.
   */
  async function mkdirs(dirPath, its) {
    if (its === undefined) {
      its = 100;
    }
    if (its &lt;= 0) {
      throw Error("its was greater than 0, there is probably a loop in dirPath:" +
        `${dirPath}`);
    }
    try {
      const stats = await stat(dirPath);
      if (!stats.isDirectory) {
        throw Error(`${dirPath} exists but is not a directory.`);
      }
    } catch (error) {
      // file does not exist
      if (error.code === "ENOENT") {
        const parentDirName = path.dirname(dirPath);
        // recusrion, yay!
        await mkdirs(parentDirName, its - 1);
        await mkdir(dirPath);
      } else {
        throw error;
      }
    }
  }

  // path is a parameter in openDatabase() so define the function we need here
  const dirname = path.dirname;
  /**
   * Opens a sqlite database. Creates if none exists.
   * @function
   * @alias module:sqlite-manager.openDatabase
   * @param {string} path - The path of the db
   * @param {string} type - The type of the db: "file" or "memory"
   * @param {string} mode - The open mode of the db: "w+" or "rw" or "r"
   * @returns {object} - Returns the promise with the sqlite3 db object from module node-sqlite3
   */
  manager.openDatabase = function(path, type, mode) {
    let db;
    return new Promise(async(resolve, reject) => {
      const databasePath = (type === sqliteConstants.DATABASE_FILE_TYPE) ? path : sqliteConstants.DATABASE_MEMORY_MODE;
      let databaseMode = sqlite3.OPEN_READONLY;

      if (mode === "w+") // Create for read and write
        databaseMode = sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE;
      else if (mode === "rw" || mode === "wr") // Open for read and write
        databaseMode = sqlite3.OPEN_READWRITE;
      else if (mode === "r") // Open only for read
        databaseMode = sqlite3.OPEN_READONLY;

      if (type === sqliteConstants.DATABASE_FILE_TYPE) {
        // makes sure the parent directory exists
        await mkdirs(dirname(databasePath));
      }

      db = new sqlite3.Database(databasePath, databaseMode, (error) => {
        if (error) reject(error);
        else resolve();
      });
    })
    .then(() => {
      // Generate an id to store the general schema in the dictionary
      db.id = shortid.generate();

      // Check if info table exists (the dataset might not be created yet)
      return sqliteInfoTable.checkInfoTable(db);
    })
    .then((result) => {
      // Get the tdx schema definition
      if (result)
        return sqliteInfoTable.getInfoKeys(db, ["schema"])
          .then((tdxSchema) => {
            if (tdxSchema.length) {
              // Dataset schema definition
              tdxSchema[0].schema = tdxSchema[0].schema || {};

              // Dataset data schema
              tdxSchema[0].schema.dataSchema = tdxSchema[0].schema.dataSchema || {};

              return Promise.resolve(sqliteConverter.convertSchema(tdxSchema[0].schema.dataSchema));
            } else
              return Promise.resolve({});
          });
      else
        return Promise.resolve({});
    })
    .then((schema) => {
      // Assign the generqal schema if the info table exists and the dataset exists
      // Will be empty otherwise
      setGeneralSchema(db, schema);
      return Promise.resolve(db);
    });
  };

  /**
   * Closes a sqlite database.
   * @function
   * @alias module:sqlite-manager.closeDatabase
   * @param {object} db - The sqlite3 db object from module node-sqlite3
   * @returns {object} - The empty promise or error
   */
  manager.closeDatabase = function(db) {
    return new Promise((resolve, reject) => {
      db.close((error) => {
        if (error) reject(error);
        else {
          // Clean the general schema
          setGeneralSchema(db, {});
          resolve({});
        }
      });
    });
  };

  /**
   * Creates a dataset in the sqlite database.
   * @function
   * @alias module:sqlite-manager.createDataset
   * @param {object} db - The sqlite3 db object from module node-sqlite3
   * @param  {object} options - details of the dataset to be added
   * @param  {string} [options.basedOnSchema="dataset"] - the id of the schema on which this resource will be based.
   * @param  {object} [options.derived] -
   *     definition of derived filter, implying this resource is a view on an existing dataset.
   * @param  {object} [options.derived.filter] - the (read) filter to apply, in mongodb query format,
   *     e.g. `{"temperature": {"$gt": 15}}` will mean that only data with a temperature value greater than 15 will be
   *     available in this view. The filter can be any arbitrarily complex mongodb query. Use the placeholder
   *     `"@@_identity_@@"` to indicate that the identity of the currently authenticated user should be substituted.
   *     For example, if the user `bob@acme.com/tdx.acme.com` is currently authenticated, a filter of `{"username":
   *     "@@_identity_@@"}` will resolve at runtime to `{"username": "bob@acme.com/tdx.acme.com"}`.
   * @param  {object} [options.derived.projection] - the (read) projection to apply, in mongodb projection format,
   *     e.g. `{"timestamp": 1, "temperature": 1}` implies only the 'timestamp' and 'temperature' properties will be
   *     returned.
   * @param  {string} [options.derived.source] - the id of the source dataset on which to apply the filters and
   *     projections.
   * @param  {object} [options.derived.writeFilter] - the write filter to apply, in mongodb query format. This
   *     controls what data can be written to the underlying source dataset. For example, a write filter of
   *     `{"temperature": {"$lt": 40}}` means that attempts to write a temperature value greater than or equal to `40`
   *     will fail. The filter can be any arbitrarily complex mongodb query.
   * @param  {object} [options.derived.writeProjection] - the write projection to apply, in mongodb projection format.
   *     This controls what properties can be written to the underlying dataset. For example, a write projection of
   *     `{"temperature": 1}` means that only the temperature field can be written, and attempts to write data to other
   *     properties will fail. To allow a view to create new data in the underlying dataset, the primary key fields
   *     must be included in the write projection.
   * @param  {string} [options.description] - a description for the resource.
   * @param  {string} [options.id] - the requested ID of the new resource. Must be unique.
   *     Will be auto-generated if omitted (recommended).
   * @param  {string} [options.name] - the name of the resource. Must be unique in the parent folder.
   * @param  {object} [options.meta] - a free-form object for storing metadata associated with this resource.
   * @param  {string} [options.parentId] - the id of the parent resource.
   *     If omitted, will default to the appropriate root folder based on the type of resource being created.
   * @param  {string} [options.provenance] - a description of the provenance of the resource.
   *     Markdown format is supported.
   * @param  {object} [options.schema] - optional schema definition.
   * @param  {object} [options.schema.dataSchema] - data schema definition object. Has TDX object structure.
   * @param  {object[]} [options.schema.uniqueIndex] - array of key value pairs denoting
   *     the ascending or descending order of the columns.
   * @param  {string} [options.shareMode] - the share mode assigned to the new resource.
   *     One of [`"pw"`, `"pr"`, `"tr"`], corresponding to:
   *     "public read/write", "public read/trusted write", "trusted only".
   * @param  {string[]} [options.tags] - a list of tags to associate with the resource.
   * @returns {object} - The id of the dataset created
   * @example &lt;caption>create a dataset with give id and schema&lt;/caption>
   *  manager.createDataset(db, {
   *    "id": "12345",
   *    "schema": {
   *      "dataSchema": {
   *        "prop1": {"__tdxType": ["number"]}
   *      },
   *      "uniqueIndex": [{"asc": "prop1"}]
   *    }
   *  });
   */
  manager.createDataset = function(db, options) {
    // Dataset id
    options.id = options.id || "";

    if (options.id === "") options.id = shortid.generate();

    // Initialise an empty schema
    options.schema = options.schema || {};

    // Dataset data schema
    options.schema.dataSchema = options.schema.dataSchema || {};

    // Dataset primary key definitoin
    options.schema.uniqueIndex = options.schema.uniqueIndex || [];

    // If there's no schema and no index set options to empty
    if (_.isEmpty(options.schema.dataSchema) &amp;&amp; !options.schema.uniqueIndex.length)
      options.schema = {};
    else if (_.isEmpty(options.schema.dataSchema) &amp;&amp; !options.schema.uniqueIndex.length)
      // reject early if there's a unique index but no schema
      return Promise.reject(Error("[sqlite-manager]: index doesn't match schema"));

    return sqliteInfoTable.checkInfoTable(db)
      .then((result) => {
        // Check if schema match
        if (result) {
          return sqliteInfoTable.getInfoKeys(db, ["id", "schema"])
            .then((pair) => {
              pair[0].id = pair[0].id || "";
              pair[1].schema = pair[1].schema || {};

              // Keep the original id
              options.id = pair[0].id;

              // Check for schema equality
              if (_.isEqual(pair[1].schema, options.schema))
                return Promise.resolve(true);
              else
                return Promise.reject(Error("[sqlite-manager]: schemas don't coincide"));
            });
        } else return sqliteInfoTable.createInfoTable(db).then(() => (false));
      })
      .then((infoExists) => {
        // Convert from tdx to a general sqlite schema
        // Assign to general schema
        setGeneralSchema(db, sqliteConverter.convertSchema(options.schema.dataSchema));

        if (!infoExists)
          return sqliteInfoTable.setInfoKeys(db, _.map(options, (value, key) => {
            const pair = {};
            pair[key] = value;
            return pair;
          })).then(() => (infoExists));

        return Promise.resolve(infoExists);
      })
      .then((infoExists) => {
        // Don't proceed with the data table
        if (infoExists)
          return Promise.resolve();

        // Map the converted schema to a valid sqlite schema and them map it to a string
        const schema = manager.getGeneralSchema(db);
        const sqliteSchemaKeys = _.map(sqliteConverter.mapSchema(schema), (value, key) => {
          return `${key} ${value}`;
        });

        let tableColumnStr = "";
        // Create the sqlite "CREATE TABLE" query index definition
        _.forEach(sqliteSchemaKeys, (value, idx) => {
          tableColumnStr += `${value}${(idx &lt; sqliteSchemaKeys.length - 1) ? "," : ""}`;
        });

        // Create the sqlite "CREATE TABLE" query primary key definition
        let sqlitePrimaryKeyStr = "";

        _.forEach(options.schema.uniqueIndex, (value, idx) => {
          let sortType = sqliteConstants.SQLITE_SORT_TYPE_ASC;
          let sortValue = "";

          // Differentiate between ascending and descending sorting
          if (value.asc !== undefined)
            sortValue = value.asc;
          else if (value.desc !== undefined) {
            sortType = sqliteConstants.SQLITE_SORT_TYPE_DESC;
            sortValue = value.desc;
          }

          const endComma = (idx &lt; options.schema.uniqueIndex.length - 1) ? "," : "";

          sqlitePrimaryKeyStr += `${sortValue} ${sortType}${endComma}`;
        });

        let createPromise = Promise.resolve({});
        if (tableColumnStr !== "") {
          // Create the table without the index
          const createTableQuery = `CREATE TABLE ${sqliteConstants.DATABASE_DATA_TABLE_NAME}(${tableColumnStr})`;
          createPromise = db.runAsync(createTableQuery, []);

          if (sqlitePrimaryKeyStr !== "")
            // Create the index
            createPromise = createPromise.then(() => {
              return db.runAsync(
                `CREATE UNIQUE INDEX ${sqliteConstants.DATABASE_TABLE_INDEX_NAME} ` +
                `ON ${sqliteConstants.DATABASE_DATA_TABLE_NAME}(${sqlitePrimaryKeyStr})`,
                []);
            });
        }

        return createPromise;
      })
      .then(() => {
        // Return the id of the table can be generated or given as a parameter
        return Promise.resolve(options.id);
      });
  };

  /**
   * Returns the general schema.
   * @function
   * @alias module:sqlite-manager.getGeneralSchema
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @returns {object} - The general schema object
   */
  manager.getGeneralSchema = function(db) {
    return generalSchema[db.id];
  };

  /**
   * Add data to a dataset resource.
   * @function
   * @async
   * @alias module:sqlite-manager.addData
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {object|array} data - The data to add.
   *     Must conform to the schema defined by the resource metadata.
   *     Supports creating an individual document or many documents.
   * @return  {Promise&lt;object&lt;string, int>>}
   *     - The promise with the total count of rows added.
   * @example &lt;caption>create an individual document&lt;/caption>
   * // returns {"count": 1} if successful
   * manager.addData(db, {lsoa: "E0000001", count: 398});
   * @example &lt;caption>create multiple documents&lt;/caption>
   * manager.addData(db, [
   *  {lsoa: "E0000001", count: 398},
   *  {lsoa: "E0000002", count: 1775},
   *  {lsoa: "E0000005", count: 4533},
   * ]);
   */
  manager.addData = async function(db, data) {
    const schema = manager.getGeneralSchema(db);
    const dataToConvert = [].concat(data);
    // convert all the data to SQLite types
    const sqlData = dataToConvert.map((row) => {
      return sqliteConverter.convertRowToSqlite(schema, row);
    });
    const infoTable = await sqliteInfoTable.getInfoKeys(db, ["schema"]);
    const uniqueIndex = infoTable[0].schema.uniqueIndex;

    // set function for creating SQLite String, INSERT
    const upsert = false;
    const makeSqlStatementStr = (dataRowKeys) => {
      return insertStatement(uniqueIndex, schema, dataRowKeys, upsert);
    };

    // throws an error if it fails
    await sqliteHelper.executeMany(db, makeSqlStatementStr,
      sqlData);
    return {"count": sqlData.length};
  };

  /**
   * @deprecated use {@link getData()}
   * Gets all data from the given dataset that matches the filter provided.
   * @function
   * @alias module:sqlite-manager.getDatasetData
   * @param  {object} db - The id of the dataset-based resource.
   * @param  {object} [filter] - A mongodb filter object. If omitted, all data will be retrieved.
   * @param  {object} [projection] - A mongodb projection object. Should be used to restrict the payload to the
   * minimum properties needed if a lot of data is being retrieved.
   * @param  {object} [options] - A mongodb options object. Can be used to limit, skip, sort etc. Note a default
   * `limit` of 1000 is applied if none is given here.
   * @param  {bool} [options.nqmMeta] - When set, the resource metadata will be returned along with the dataset
   * data. Can be used to avoid a second call to `getResource`. Otherwise a URL to the metadata is provided.
   * @return  {DatasetData}
   */
  manager.getDatasetData = function(db, filter, projection, options) {
    return getDataQuery(db, false, filter, projection, options);
  };

  /**
   * Gets all data from the given dataset that matches the filter provided.
   * @alias module:sqlite-manager.getData
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {object} [filter] - A mongodb filter object. If omitted, all data will be retrieved.
   * @param {object} [projection] - A mongodb projection object. Should be used to restrict the payload to the
   * minimum properties needed if a lot of data is being retrieved.
   * @param {object} [options] - A mongodb options object. Can be used to limit, skip, sort etc. Note a default
   * `limit` of 1000 is applied if none is given here.
   * @param {number} [options.skip] - Number of documents to skip.
   * @param {number} [options.limit] - Limit number of documents to output.
   * @param {number} [options.sort] - Sorting object by schema keys:
   *    e.g. `{prop1: 1, prop2: -1}`, where `1` = ascending, `-1` = descending.
   * @param {boolean} [options.nqmMeta] - When set, the resource metadata will be returned along with the dataset
   * data. Can be used to avoid a second call to `getResource`. Otherwise a URL to the metadata is provided.
   * @return {DatasetData}
   */
  manager.getData = function(db, filter, projection, options) {
    return getDataQuery(db, false, filter, projection, options);
  };

  /**
   * Gets a list of distinct values for a given property in a dataset-based resource.
   * @alias module:sqlite-manager.getDistinct
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {string} key - The name of the property to use. Can be a property path, e.g. "address.postcode".
   * @param {object} [filter] - An optional mongodb filter to apply.
   * @return {object[]}
   */
  manager.getDistinct =  function(db, key, filter) {
    const projection = {};

    if (key !== "")
      projection[key] = 1;

    return getDataQuery(db, true, filter, projection, {});
  };

  /**
   * Gets all data from the given dataset that matches the filter provided and the select provided.
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {boolean} [distinct] - Select type ("select" - 0, "select distinct" - 1).
   * @param {object} [filter] - A mongodb filter object. If omitted, all data will be retrieved.
   * @param {object} [projection] - A mongodb projection object. Should be used to restrict the payload to the
   * minimum properties needed if a lot of data is being retrieved.
   * @param {object} [options] - A mongodb options object. Can be used to limit, skip, sort etc. Note a default
   * `limit` of 1000 is applied if none is given here.
   * @param {number} [options.skip] - Number of documents to skip.
   * @param {number} [options.limit] - Limit number of documents to output.
   * @param {number} [options.sort] - Sorting object by schema keys:
   *    e.g. `{prop1: 1, prop2: -1}`, where `1` = ascending, `-1` = descending.
   * @param {boolean} [options.nqmMeta] - When set, the resource metadata will be returned along with the dataset
   * data. Can be used to avoid a second call to `getResource`. Otherwise a URL to the metadata is provided.
   * @return {DatasetData}
   */
  function getDataQuery(db, distinct, filter, projection, options) {
    // Set the default values
    filter = filter || {};
    projection = projection || {};
    options = options || {};

    const skip = options.skip || 0;
    const limit = options.limit;
    const sort = options.sort || {};

    const nqmMeta = options.nqmMeta || false;

    const selectQuery = {
      type: "select",
      table: sqliteConstants.DATABASE_DATA_TABLE_NAME,
      where: filter,
      distinct: distinct,
    };

    // Set the limit for the number of documents that need to be retrieved
    if (limit === undefined)
      selectQuery.limit = queryLimit;
    else {
      if (limit > queryLimit)
        selectQuery.limit = queryLimit;
      else if (limit > 0 &amp;&amp; limit &lt;= queryLimit)
        selectQuery.limit = limit;
    }

    // Set the offset aka skip in mongodb
    if (skip) selectQuery.offset = skip;

    // Set the sort order (ascending or descending)
    const sortQuery = {};
    _.forEach(sort, (value, key) => {
      if (value === 1)
        sortQuery[key] = sqliteConstants.SQLITE_SORT_TYPE_ASC;
      else if (value === -1)
        sortQuery[key] = sqliteConstants.SQLITE_SORT_TYPE_DESC;
    });

    if (!_.isEmpty(sortQuery)) selectQuery.order = sortQuery;

    // Set the projection columns
    const schema = manager.getGeneralSchema(db);
    const excludedColumns = Object.keys(schema);
    const includedColumns = [];
    _.forEach(projection, (value, key) => {
      if (key in schema) {
        if (value)
          includedColumns.push(key);
        else {
          const keyIdx = excludedColumns.indexOf(key);
          if (keyIdx >= 0) excludedColumns.splice(keyIdx, 1);
        }
      }
    });

    if (includedColumns.length)
      selectQuery.columns = includedColumns;
    else if (excludedColumns.length &amp;&amp; !includedColumns.length)
      selectQuery.columns = excludedColumns;

    const sqliteTranslation = builder.sql(selectQuery, []);

    // Set the return value
    let result;

    if (distinct === false) {
      result = {
        metaData: {},
        metaDataUrl: "",
        data: [],
      };

      if (nqmMeta) result.metaData = manager.getResource(db);
    } else result = [];

    // Return early if no columns selected
    if (selectQuery.columns.length === 1 &amp;&amp; selectQuery.columns[0] === "*")
      return Promise.resolve(result);

    // Return early if no columns selected if no projection selected or more fields selected
    if (distinct === true &amp;&amp; includedColumns.length !== 1)
      return Promise.resolve(result);

    return db.allAsync(sqliteTranslation.query, sqliteTranslation.values)
      .then((rows) => {
        // Check if there's an object or array type in the generalSchema object
        // Convert each element of the rows
        // Becomes slow if one of the types is object or array
        if (_.includes(schema, sqliteConstants.SQLITE_GENERAL_TYPE_OBJECT) ||
            _.includes(schema, sqliteConstants.SQLITE_GENERAL_TYPE_ARRAY)
          ) {
            // Check if it's not select distinct
          if (distinct === false) {
            _.forEach(rows, (row) => {
              const convertedRow = {};

              _.forEach(row, (value, key) => {
                convertedRow[key] = sqliteConverter.convertToTdx(schema[key], value);
              });

              result.data.push(convertedRow);
            });
          } else {
            const key = includedColumns[0];
            _.forEach(rows, (row) => {
              result.push(sqliteConverter.convertToTdx(schema[key], row[key]));
            });
          }
        } else {
          if (distinct === false)
            result.data = rows;
          else {
            const key = includedColumns[0];

            _.forEach(rows, (row) => {
              result.push(row[key]);
            });
          }
        }

        return Promise.resolve(result);
      });
  }

  /**
   * Makes an SQLite Statement for an insertion.
   *
   * If dataRowKeys is missing a column that is in the schema, it is not added
   * into the statement.
   * This is so an insert adds the SQLite Column default value, and if there is
   * an update, only the defined columns are changed.
   * @param {object} uniqueIndex - The uniqueIndex to upsert.
   * @param {object} schema - The schema of the database.
   * @param {array&lt;string>} dataRowKeys - The column names for the data row.
   * @param {bool} upsert - If true, updates if the data already exists.
   * @returns {string} - The SQLite insert/upsert statement.
   */
  function insertStatement(uniqueIndex, schema, dataRowKeys, upsert) {
    let tableColumnStr = "";
    let sqliteValue = "";
    let updateStr = "";

    const schemaColumnsSet = new Set(Object.keys(schema));

    dataRowKeys.forEach((column) => {
      if (schemaColumnsSet.has(column)) {
        const escapedCol = sqliteConverter.escapeIdentifier(column);
        tableColumnStr += `${escapedCol}, `;
        sqliteValue += "?, ";
        updateStr += `${escapedCol}=excluded.${escapedCol}, `;
      } else {
        // I think current behavior is just to ignore errors but maybe we
        // should let SQLite throw the error
      }
    });
    // returns an empty string if there is nothing in there
    // else cuts out the last ", " (command and space)
    tableColumnStr = tableColumnStr.slice(0, -2);
    if (tableColumnStr.length === 0) {
      throw new Error("No columns matching the schema were given.");
    }
    sqliteValue = sqliteValue.slice(0, -2);
    updateStr = updateStr.slice(0, -2);

    let sqlStatement = "INSERT INTO " +
      `${sqliteConstants.DATABASE_DATA_TABLE_NAME}(${tableColumnStr}) ` +
      `VALUES(${sqliteValue})`;

    if (upsert) {
      let conflictStr = uniqueIndex.reduce( (string, column) => {
        const value = Object.values(column)[0];
        return `${string}${sqliteConverter.escapeIdentifier(value)}, `;
      }, "");
      conflictStr = conflictStr.slice(0, -2);
      if (conflictStr.length === 0) {
        throw new Error("No uniqueIndex was given.");
      }
      sqlStatement += ` ON CONFLICT(${conflictStr}) DO UPDATE SET ${updateStr}`;
    }

    // finish SQLStatement
    sqlStatement += ";";
    return sqlStatement;
  }

    /**
   * Makes an SQLite Statement for an update.
   *
   * If dataRowKeys is missing a column that is in the schema, it is not added
   * into the statement.
   * This is so an insert adds the SQLite Column default value, and if there is
   * an update, only the defined columns are changed.
   * @param {object} uniqueIndex - The uniqueIndex to upsert.
   * @param {object} schema - The schema of the database.
   * @param {array&lt;string>} dataRowKeys - The column names for the data row.
   * @returns {string} - The SQLite insert/upsert statement.
   *
   * @example
   *   // returns
   *   // `UPDATE table SET "unique" = :a(unique) WHERE "unique" = :a(unique);`
   *   updateStatement([{"asc": "unique"}], {"unique": "TEXT"}, ["unique"]);
   */
  function updateStatement(uniqueIndex, schema, dataRowKeys) {
    let updateStr = "";

    const schemaColumnsSet = new Set(Object.keys(schema));

    dataRowKeys.forEach((column) => {
      if (schemaColumnsSet.has(column)) {
        const escapedCol = sqliteConverter.escapeIdentifier(column);
        const namedParameter = sqliteConverter.makeNamedParameter(column);
        // "column_name = :a(column_name), "
        updateStr += `${escapedCol} = ${namedParameter}, `;
      } else {
        // I think current behavior is just to ignore errors but maybe we
        // should let SQLite throw the error
      }
    });
    // returns an empty string if there is nothing in there
    // else cuts out the last ", " (command and space)
    updateStr = updateStr.slice(0, -2);
    if (updateStr.length === 0) {
      throw new Error("No columns matching the schema were given.");
    }

    let sqlStatement = "UPDATE " +
      `${sqliteConstants.DATABASE_DATA_TABLE_NAME} ` +
      `SET ${updateStr}`;

    let conditionStr = "";
    uniqueIndex.forEach((uniqueIndexColumn) => {
      const column = Object.values(uniqueIndexColumn)[0]; // key is order
      if (!dataRowKeys.includes(column)) {
        throw Error(`The keys ${dataRowKeys} were given for an UPDATE ` +
          `statement but the unique index column ${column} was not specified.`);
      }
      const escapedCol = sqliteConverter.escapeIdentifier(column);
      const namedParameter = sqliteConverter.makeNamedParameter(column);
      conditionStr += `${escapedCol} = ${namedParameter}, `;
    });
    conditionStr = conditionStr.slice(0, -2);
    if (conditionStr.length === 0) {
      throw new Error("No uniqueIndex was given.");
    }
    sqlStatement += ` WHERE ${conditionStr}`;

    // finish SQLStatement
    sqlStatement += ";";
    return sqlStatement;
  }

  /**
   * Updates data in a dataset resource.
   * @alias module:sqlite-manager.updateData
   * @async
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {object|array&lt;object>} data - The data to update.
   *     Must conform to the schema defined by the resource metadata.
   *     Supports updating individual or multiple rows.
   * @param {bool} [upsert=false] - Indicates the data should be created if no
   *     document/row is found matching the primary key.
   * @param {bool} [throws=true] - Indicates whether this function should reject
   *     if there is an error. The TDX-API doesn't, as it returns a field which
   *     states if there has been an error.
   * @returns {Promise&lt;CommandResult>} - Use the result property to check for
   *     errors.
   */
  manager.updateData = async function(db, data, upsert, throws) {
    // See https://www.sqlite.org/lang_UPSERT.html for more info.

    // setup default values
    let set_upsert = upsert;
    if (set_upsert === undefined) {
      set_upsert = false;
      throw Error("upsert === false is not supported yet.");
    }
    let set_throws = throws;
    if (set_throws === undefined) {
      set_throws = true;
    }

    const schema = manager.getGeneralSchema(db);
    const dataToConvert = [].concat(data);
    const sqlData = dataToConvert.map((row) => {
      return sqliteConverter.convertRowToSqlite(schema, row);
    });
    const infoTable = await sqliteInfoTable.getInfoKeys(db, ["schema"]);
    const uniqueIndex = infoTable[0].schema.uniqueIndex;

    // set function for creating SQLite String, either INSERT/UPDATE
    let makeSqlStatementStr = (dataRowKeys) => {
      return updateStatement(uniqueIndex, schema, dataRowKeys);
    };
    if (upsert) makeSqlStatementStr = (dataRowKeys) => {
      return insertStatement(uniqueIndex, schema, dataRowKeys, upsert);
    };

    const promisedResult = sqliteHelper.executeMany(db, makeSqlStatementStr,
      sqlData);

    const commandResult = await makeEmptyCommandResult();
    try {
      await promisedResult;
    } catch (error) {
      if (set_throws) {
        throw error;
      } else {
        commandResult.result.errors.push(error);
        return commandResult;
      }
    }
    commandResult.response = "Success";
    return commandResult;
  };

  /**
   * Updates data in a dataset-based resource using a query to specify the documents to be updated.
   * @alias module:sqlite-manager.updateDataByQuery
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {object} query - The query that specifies the data to update. All documents matching the
   * query will be updated.
   * @param {object} update - The update object with field data to be replaced.
   * @return  {object} - The promise with the total count of rows updated.
   * @example &lt;caption>updates multiple documents&lt;/caption>
   * // Update all documents with English lsoa, setting `count` to 1000.
   * manager.updateDataByQuery(db, {lsoa: {$regex: "E*"}}, {count: 1000});
   */
  manager.updateDataByQuery = function(db, query, update) {
    let whereClause = "";

    // Set the default values
    query = query || {};
    update = update || {};

    const updateQuery = {
      type: "update",
      table: sqliteConstants.DATABASE_DATA_TABLE_NAME,
      where: query,
      updates: update,
    };

    const countQuery = {
      type: "select",
      table: sqliteConstants.DATABASE_DATA_TABLE_NAME,
      where: query,
    };

    // Return early if update is empty
    if (_.isEmpty(update))
      return Promise.resolve({count: 0});

    // Built the count and update queries using the filter
    const sqliteUpdateTranslation = builder.sql(updateQuery, []);

    // Built the count and update queries using the filter
    const sqliteCountTranslation = builder.sql(countQuery, []);

    // Copy the where clause if exists
    const clauseIdx = sqliteCountTranslation.query.indexOf("where");
    if (clauseIdx >= 0)
      whereClause = ` ${sqliteCountTranslation.query.slice(clauseIdx)}`;

    return new Promise((resolve, reject) => {
      db.serialize(() => {
        let result = {};

        // Count the total number of rows in the dataset for a given query
        db.get(
          `SELECT Count(*) AS count FROM ${sqliteConstants.DATABASE_DATA_TABLE_NAME}${whereClause};`,
          sqliteCountTranslation.values,
          (error, row) => {
            if (error) reject(error);
            else result = row;
          }
        );

        db.run(`${sqliteUpdateTranslation.query};`, sqliteUpdateTranslation.values, (error) => {
          if (error) reject(error);
          else resolve(result);
        });
      });
    });
  };


  /**
   * Truncates the dataset resource.
   * @function
   * @alias module:sqlite-manager.truncateResource
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @return  {object} - The promise with the total count of rows deleted.
   */
  manager.truncateResource = function(db) {
    return new Promise((resolve, reject) => {
      db.serialize(() => {
        let result = {};
        // Count the total number of rows in the dataset
        db.get(`SELECT Count(*) AS count FROM ${sqliteConstants.DATABASE_DATA_TABLE_NAME};`, [], (error, row) => {
          if (error) reject(error);
          else result = row;
        });

        db.run(`DELETE FROM ${sqliteConstants.DATABASE_DATA_TABLE_NAME};`, [], (error) => {
          if (error) reject(error);
        });

        db.run("VACUUM;", [], (error) => {
          if (error) reject(error);
          else resolve(result);
        });
      });
    });
  };

  /**
   * Gets a count of the data in a dataset-based resource, after applying the given filter.
   * @function
   * @alias module:sqlite-manager.getDatasetDataCount
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {object} filter - An optional mongodb filter to apply before counting the data.
   * @return  {object} - The promise with the total count of rows.
   */
  manager.getDatasetDataCount = function(db, filter) {
    let whereClause = "";
    filter = filter || {};

    const countQuery = {
      type: "select",
      table: sqliteConstants.DATABASE_DATA_TABLE_NAME,
      where: filter,
    };

    // Build the count query using the filter
    const sqliteTranslation = builder.sql(countQuery, []);

    // Copy the where clause if exists
    const clauseIdx = sqliteTranslation.query.indexOf("where");
    if (clauseIdx >= 0)
      whereClause = ` ${sqliteTranslation.query.slice(clauseIdx)}`;

    return db.getAsync(
      `SELECT Count(*) AS count FROM ${sqliteConstants.DATABASE_DATA_TABLE_NAME}${whereClause};`,
      sqliteTranslation.values);
  };

  /**
   * Gets the details for a given database.
   * @async
   * @function
   * @alias module:sqlite-manager.getResource
   * @param  {object} db - The sqlite3 db object from module node-sqlite3.
   * @param  {bool} [noThrow=false] - If set, the call won't reject or throw if the resource doesn't exist.
   * @return  {Promise&lt;Resource>}
   * @exception  Will throw/reject if the resource is not found (see `noThrow` flag) or permission is denied.
   */
  manager.getResource = async function(db, noThrow) {
    let info_keys;
    const keysToDisplayKeys = sqliteConstants.INFO_TABLE_KEYS_TO_TDX_RESOURCE_KEYS;

    if (noThrow) {
      throw Error("noThrow is currently unimplemented, just try/catch your code");
    }
    try {
      info_keys = await sqliteInfoTable.getInfoKeys(db, Object.keys(
        keysToDisplayKeys));
    } catch (error) {
      // I know this shouldn't be in a try/catch block, but if we ever implement
      // noThrow again, it would be here
      throw error;
    }
    const resource = {};
    const defaultValue = null;
    // fill up resource with the default values
    Object.keys(keysToDisplayKeys).forEach( (key) => {
      const displayKey = keysToDisplayKeys[key];
      resource[displayKey] = defaultValue;
    });
    // map keys from info table to TDX Resource definition.
    info_keys.forEach( (infoKey) => {
      Object.keys(infoKey).forEach( (key) => {
        resource[keysToDisplayKeys[key]] = infoKey[key];
      });
    });
    return resource;
  };

  /**
   * Sets the general schema and the default NULL array.
   * @function
   * @alias module:sqlite-manager.setGeneralSchema
   * @param {object} db - The sqlite3 db object from module node-sqlite3.
   * @param {object} schema - The general schema.
   */
  function setGeneralSchema(db, schema) {
    generalSchema[db.id] = schema;
  }

  return manager;
}());
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-sqlite-helper.html">sqlite-helper</a></li><li><a href="module-sqlite-info-table.html">sqlite-info-table</a></li><li><a href="module-sqlite-manager.html">sqlite-manager</a></li><li><a href="module-sqlite-schema-converter.html">sqlite-schema-converter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#INFO_TABLE_KEYS_TO_TDX_RESOURCE_KEYS">INFO_TABLE_KEYS_TO_TDX_RESOURCE_KEYS</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Aug 02 2018 11:25:47 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
